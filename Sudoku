import numpy as np
import copy
import timeit
import random

class SudokuPuzzle:
    def __init__(self, final_values = None, n = 9):
        self.n = n 
        if final_values is None:
            self.final_values = [[-1] * self.n]*self.n
        else:
            self.final_values = final_values
            
        for i in range(0,n):
            for j in range(0,n):
                if self.final_values[i][j]== 0:
                    self.final_values[i][j] = -1
        
        #list of possible values for each box - how do I do this for each box 
        self.possible_values = [[[i for i in range(1, 10)] for _ in range(0,9)]for _ in range(0, 9)]
        
        for i in range(0,n):
            for j in range(0,n):
                self.possible_values[i][j].append(-1)
                if self.final_values[i][j]!= -1:
                    self.possible_values[i][j] = []
                    
        tidy_up_poss_values = [(ix,iy) for ix, row in enumerate(partial_state.possible_values) for iy, value in enumerate(row) if self.final_values[ix][iy]== -1]
        for square in tidy_up_poss_values:
            for values in self.final_values[square[0]][:]:
                self.possible_values[square[0]][square[1]].remove(values)
            #for values in the same column: 
                #self.possible_values[square[0]][square[1]].remove (XXXX)
            #for values in the same 3X3:
                #self.possible_values[square[0]][square[1]].remove (XXXX)
                                                           
    def is_goal(self):
        #goal state if all the boxes have a value 
        #check that all values in the sudoku are not -1
        array = np.array(self.final_values)
        return np.all((array != -1))
    
    def is_invalid(self):
        for row in self.possible_values: 
            if any(len(value) == 0 for value in row):
                return True
            else:
                return False
    
    def get_possible_values(self, column, row):        
        return self.possible_values[column][row].copy()
    
    def get_final_state(self):
        if self.is_goal():
            return self.final_values
        else:
            return -1
        
    def get_singleton_square(self):
        singleton_square = [(ix,iy) for ix, row in enumerate(self.possible_values) for iy, value in enumerate(row) if len(value) == 1 and self.final_values[ix][iy]== -1]
        #print(singleton_square)
        return singleton_square
    
    def set_value(self, row, column, value):
        #first reject if the value isn't in [column][row]
        #if value not in self.possible_values[row][column]:
            #raise ValueError(f"{value} is not a valid choice for box in row {row}, column {column}")
        
        #create a deep copy: return a new state & do not modify the deep copy
        state = copy.deepcopy(self)
        
        #update this box 
        state.possible_values[row][column] = [value]
        state.final_values[row][column] = value
        
        #now update all boxes in same row to the left: 
        for self.possible_values[row] in self.possible_values: 
            for j in range(0, column):
                if value in self.possible_values[row][j]:
                    self.possible_values[row][j].remove(value)
            
        #now update all boxes in same row to the right: 
        for self.possible_values[row] in self.possible_values: 
            for j in range(column +1, state.n):
                if value in self.possible_values[row][j]:
                    self.possible_values[row][j].remove(value)
                    
        #now update all boxes in same column above:
        for i in range(0,row): 
            if value in self.possible_values[i][column]: 
                self.possible_values[i][column].remove(value)
                    
        #now update all boxes in column below: 
        for i in range(row+1,state.n): 
            if value in self.possible_values[i][column]: 
                self.possible_values[i][column].remove(value)
                
        #now update all boxes in the 3 x 3 matrix the box is in: 
        if row in range(0,3):
            if column in range(0,3):
                for i in range(0,3):
                    for j in range(0,3):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
            if column in range(3,6):
                for i in range(0,3):
                    for j in range(3,6):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
            if column in range(6,9):
                for i in range(0,3):
                    for j in range(6,9):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
        if row in range(3,6):
            if column in range(0,3):
                for i in range(3,6):
                    for j in range(0,3):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
            if column in range(3,6):
                for i in range(3,6):
                    for j in range(3,6):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
            if column in range(3,6):
                for i in range(6,9):
                    for j in range(6,9):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
        if row in range(6,9):
            if column in range(0,3):
                for i in range(6,9):
                    for j in range(0,3):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
            if column in range(3,6):
                for i in range(6,9):
                    for j in range(3,6):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)
            if column in range(6,9):
                for i in range(6,9):
                    for j in range(6,9):
                        if value in self.possible_values[i][j]: 
                            self.possible_values[i][j].remove(value)                      
        
        #if any boxes have only 1 possible single value: 
        singleton_squares = state.get_singleton_square()
        while len(singleton_squares)>0:
            singleton_square = singleton_squares[0]
            state = state.set_value(singleton_square[0], singleton_square[1], state.possible_values[singleton_square[0]][singleton_square[1]])
            singleton_squares = state.get_singleton_square()        
        return state

def pick_next_square(partial_state):
    square_indices = [(ix,iy) for ix, row in enumerate(partial_state.possible_values) for iy, value in enumerate(row) if len(value) >= 1]  
    print(f"The square indices are {square_indices}")
    print(partial_state.possible_values[0][1])
    print(partial_state.possible_values)
    return random.choice(square_indices)
    
def order_values(partial_state, square_index):
    values = partial_state.get_possible_values(square_index[0],square_index[1])
    random.shuffle(values)
    return values

def depth_first_search(partial_state):
    square_index = pick_next_square(partial_state)
    values = order_values(partial_state, square_index)
    
    for value in values:
        print(f"The value is {value}")
        print(f"The possible values are {partial_state.possible_values[square_index[0]][square_index[1]]}")
        new_state = partial_state.set_value(square_index[0], square_index[1], value)
        if new_state.is_goal():
            return new_state
        if not new_state.is_invalid():
            deep_state = depth_first_search(new_state)
            if deep_state is not None and deep_state.is_goal():
                return deep_state
    return None
     

test_sudoku = [[1,0,4,3,8,2,9,5,6], [2, 0, 5, 4, 6, 7, 1, 3, 8],[3, 8, 6, 9, 5, 1, 4, 0, 2],[4, 6, 1, 5, 2, 3, 8, 9, 7],[7, 3, 8, 1, 4, 9, 6, 2, 5],[9, 5, 2, 8, 7, 6, 3, 1, 4],[5, 2, 9, 6, 3, 4, 7, 8, 1],[6, 0, 7, 2, 9, 8, 5, 4, 3],[8, 4,3,0,1,5,2,6,9]]
partial_state = SudokuPuzzle(final_values = test_sudoku, n = 9)
starttime = timeit.default_timer()
goal = depth_first_search(partial_state).get_final_state()
print("The time difference is :", timeit.default_timer() - starttime)


#Problems with the code
#doesn't reset the possible values at the beginning based on the inputted suoku: lines 31-35 
#the value from line 172 is coming out as [#], not # (when you run the code, you will see what I mean)
#I got the following error message with my code: 
""" <ipython-input-109-73566880bab4>:47: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  array = np.array(self.final_values)"""

